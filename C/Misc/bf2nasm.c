
#include <stdio.h>
#include <stdlib.h>

/* NOTE: Can't calculate the heap size when parsing since we would have to
 * account for the loops and that basically means running the brainfuck from
 * here. */
#define HEAP_SZ 1024

/* If defined, the compiled assembly will define its own print/read/write
 * functions */
#define LINUX_SYSCALLS

/*
 * Entry point of the generated assembly.
 *
 * NOTE: If LINUX_SYSCALLS is defined, it's best to use '_start' as entry point,
 * instead of 'main'.
 */
#ifdef LINUX_SYSCALLS
#define ENTRY_POINT "_start"
#else
#define ENTRY_POINT "main"
#endif

/*
 * Will be appended to the end of 'call' instructions.
 *
 * NOTE: If LINUX_SYSCALLS is not defined, it will call LIBC functions. With the
 * 'wrt ..plt' subfix, we tell the linker to grab the address of this symbol
 * from the PLT. See:
 *   https://8dcc.github.io/reversing/understanding-call-stack.html#note-about-position-independent-executables
 */
#ifdef LINUX_SYSCALLS
#define CALL_SUBFIX ""
#else
#define CALL_SUBFIX " wrt ..plt"
#endif

/*
 * Print and read functions for the '.' and ',' brainfuck characters. The
 * printing function must take a value in 'rdi', and the read function must
 * return a value in 'rax'.
 */
#define FN_PRINT "putchar"
#define FN_READ  "getchar"

/* Will be called with zero as it's only argument when the program is done */
#define FN_EXIT "exit"

/*----------------------------------------------------------------------------*/

static char* parseInput(void) {
    size_t i = 0, buf_sz = 100;
    char* buf = calloc(buf_sz, sizeof(char));

    int c;
    while ((c = getchar()) != EOF) {
        if (i >= buf_sz) {
            buf_sz += 100;
            buf = realloc(buf, buf_sz);
        }

        switch (c) {
            case '+':
            case '-':
            case '<':
            case '>':
            case '[':
            case ']':
            case '.':
            case ',':
                /* Valid chars */
                buf[i++] = c;
                break;
            default:
                /* Ignore invalid chars and comments */
                break;
        }
    }

    buf[i] = '\0';
    return buf;
}

/*----------------------------------------------------------------------------*/

int main(void) {
    /* Get the input from the user */
    char* input = parseInput();

    /* Stack of the label indexes we stepped into */
    size_t label_stack_sz = 25, label_stack_i = 0;
    int* label_stack = malloc(label_stack_sz * sizeof(int));

    /* Total number of labels we printed */
    int label_i = 0;

    /* Print the header comment */
    printf("; Generated by bf2nasm\n"
           "; https://github.com/8dcc/scratch\n"
           ";\n"
           "; Assemble and link with:\n"
           ";   nasm -f elf64 -o file.o file.asm\n");

#ifdef LINUX_SYSCALLS
    printf(";   ld -m elf_x86_64 -o file.out file.o\n");
#else
    printf(";   gcc -o file.out file.o");
#endif

    /* Use relative offsets, specify the architecture */
    printf("default rel\n"
           "bits 64\n\n");

    /* Reserve the heap in the .bss section. Has to be nobits. */
    printf("section .bss\n"
           "heap: resb %d\n\n",
           HEAP_SZ);

#ifdef LINUX_SYSCALLS
    /* Define our own read/write/quit functions using linux syscalls */
    printf("section .text\n\n");

    printf("global %s\n"
           "%s:\n"
           "push rdi\n"
           "mov rax, 4\n"
           "mov rdi, 1\n"
           "mov rsi, rsp\n"
           "mov rdx, 1\n"
           "int 0x80\n"
           "add rsp, 8\n"
           "ret\n",
           FN_PRINT, FN_PRINT);

    printf("global %s\n"
           "%s:\n"
           "sub rsp, 8\n"
           "mov rax, 3\n"
           "mov rdi, 0\n"
           "mov rsi, rsp\n"
           "mov rdx, 1\n"
           "int 0x80\n"
           "add rsp, 8\n"
           "ret\n",
           FN_READ, FN_READ);

    printf("global %s\n"
           "%s:\n"
           "mov rax, 1\n"
           "mov rdi, 0\n"
           "int 0x80\n",
           FN_EXIT, FN_EXIT);
#else
    /* Declare the extern functions */
    printf("section .text\n"
           "extern %s:function\n"
           "extern %s:function\n"
           "extern %s:function\n\n",
           FN_PRINT, FN_READ, FN_EXIT);
#endif

    /* Print the start of our entry point */
    printf("global %s\n"
           "%s:\n",
           ENTRY_POINT, ENTRY_POINT);

    /* Clear used registers and store the heap pointer in 'rcx'.
     *
     * We have to use:
     *   lea REGISTER, [rel LABEL]
     * Instead of:
     *   mov REGISTER, LABEL
     * Because we are using addresses relative to RIP. Again, see:
     *   https://8dcc.github.io/reversing/understanding-call-stack.html#note-about-position-independent-executables
     */
    printf("xor rax, rax\n"
           "xor rax, rax\n"
           "lea rcx, [rel heap]\n");

    for (int i = 0; input[i] != '\0'; i++) {
        /* If we reached the top of the label stack, resize */
        if (label_stack_i >= label_stack_sz) {
            label_stack_sz += 25;
            label_stack = realloc(label_stack, label_stack_sz);
        }

        switch (input[i]) {
            case '+':
                puts("inc byte [rcx]");
                break;
            case '-':
                puts("dec byte [rcx]");
                break;
            case '>':
                puts("inc rcx");
                break;
            case '<':
                puts("dec rcx");
                break;
            case '[':
                printf(".lbl%d:\n", label_i);

                /* Push the current label identifier to the stack, to indicate
                 * the nesting level increased. */
                label_stack[label_stack_i++] = label_i;

                /* Increase total number of labels, so they are always unique */
                label_i++;

                break;
            case ']':
                if (label_stack_i <= 0) {
                    fprintf(stderr, "Unexpected ']' at token number %d.\n", i);
                    return 1;
                }

                /* Past this instruction, the nesting level descreases. Pop from
                 * the label stack. */
                label_stack_i--;

                printf("cmp byte [rcx], 0\n"
                       "jnz .lbl%d\n",
                       label_stack[label_stack_i]);

                break;
            case '.':
                printf("push rcx\n"
                       "mov rdi, [rcx]\n"
                       "call %s%s\n"
                       "pop rcx\n",
                       FN_PRINT, CALL_SUBFIX);
                break;
            case ',':
                printf("call %s\n"
                       "mov [rcx], rax\n",
                       FN_READ);
                break;
            default:
                fprintf(stderr, "Should not reach default case.\n");
                break;
        }
    }

    /* Exit the program */
    printf("mov rdi, 0\n"
           "call %s%s\n",
           FN_EXIT, CALL_SUBFIX);

    free(label_stack);
    free(input);
    return 0;
}
