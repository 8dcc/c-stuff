
#include <stdio.h>
#include <stdlib.h>

/* NOTE: Can't calculate the heap size when parsing since we would have to
 * account for the loops and that basically means running the brainfuck from
 * here. */
#define HEAP_SZ 1024

/* Entry point of the generated assembly */
#define ENTRY_POINT "main"

/* Print and read functions for the '.' and ',' brainfuck characters. The
 * printing function must take a value in 'rdi', and the read function must
 * return a value in 'rax'. */
#define FN_PRINT "putchar"
#define FN_READ  "getchar"

/* Will be called with zero as it's only argument when the program is done */
#define FN_EXIT "exit"

/* Will be appended to the end of 'call' instructions. Used to tell the linker
 * to grab the address of this symbol from the PLT. */
#define CALL_SUBFIX " wrt ..plt"

/*----------------------------------------------------------------------------*/

static char* parseInput(void) {
    size_t i = 0, buf_sz = 100;
    char* buf = calloc(buf_sz, sizeof(char));

    int c;
    while ((c = getchar()) != EOF) {
        if (i >= buf_sz) {
            buf_sz += 100;
            buf = realloc(buf, buf_sz);
        }

        switch (c) {
            case '+':
            case '-':
            case '<':
            case '>':
            case '[':
            case ']':
            case '.':
            case ',':
                /* Valid chars */
                buf[i++] = c;
                break;
            default:
                /* Ignore invalid chars and comments */
                break;
        }
    }

    buf[i] = '\0';
    return buf;
}

/*----------------------------------------------------------------------------*/

int main(void) {
    /* Get the input from the user */
    char* input = parseInput();

    /* Stack of the label indexes we stepped into */
    size_t label_stack_sz = 25, label_stack_i = 0;
    int* label_stack = malloc(label_stack_sz * sizeof(int));

    /* Total number of labels we printed */
    int label_i = 0;

    /* Print the header comment */
    printf("; Generated by bf2nasm\n"
           "; https://github.com/8dcc/scratch\n"
           ";\n"
           "; Assemble and link with:\n"
           ";   nasm -f elf64 -o file.o file.asm\n"
           ";   ld -m elf_x86_64 -o file.out file.o\n\n");

    /* Reserve the heap, declare the extern functions */
    printf("default rel\n\n"
           "section .bss\n"
           "heap: resb %d\n\n"
           "section .text\n"
           "extern %s:function\n"
           "extern %s:function\n"
           "extern %s:function\n\n",
           HEAP_SZ, FN_PRINT, FN_READ, FN_EXIT);

    /* Print the start of our entry point. Clear used registers and store the
     * heap pointer in 'rcx'.
     *
     * We have to use:
     *   lea REGISTER, [rel LABEL]
     * Instead of:
     *   mov REGISTER, LABEL
     * Because we are using relative addresses from the PLT. See:
     *   https://8dcc.github.io/reversing/understanding-call-stack.html#note-about-position-independent-executables
     */
    printf("global %s\n"
           "%s:\n"
           "xor rax, rax\n"
           "xor rdi, rdi\n"
           "lea rcx, [rel heap]\n",
           ENTRY_POINT, ENTRY_POINT);

    for (int i = 0; input[i] != '\0'; i++) {
        if (label_stack_i >= label_stack_sz) {
            label_stack_sz += 25;
            label_stack = realloc(label_stack, label_stack_sz);
        }

        switch (input[i]) {
            case '+':
                puts("inc byte [rcx]");
                break;
            case '-':
                puts("dec byte [rcx]");
                break;
            case '>':
                puts("inc rcx");
                break;
            case '<':
                puts("dec rcx");
                break;
            case '[':
                printf(".lbl%d:\n", label_i);

                /* Push the current label identifier to the stack, to indicate
                 * the nesting level increased. */
                label_stack[label_stack_i++] = label_i;

                /* Increase total number of labels, so they are always unique */
                label_i++;

                break;
            case ']':
                if (label_stack_i <= 0) {
                    fprintf(stderr, "Unexpected ']' at token number %d.\n", i);
                    return 1;
                }

                /* Past this instruction, the nesting level descreases. Pop from
                 * the label stack. */
                label_stack_i--;

                printf("cmp byte [rcx], 0\n"
                       "jnz .lbl%d\n",
                       label_stack[label_stack_i]);

                break;
            case '.':
                printf("push rcx\n"
                       "mov rdi, [rcx]\n"
                       "call %s%s\n"
                       "pop rcx\n",
                       FN_PRINT, CALL_SUBFIX);
                break;
            case ',':
                printf("call %s\n"
                       "mov [rcx], rax\n",
                       FN_READ);
                break;
            default:
                fprintf(stderr, "Should not reach default case.\n");
                break;
        }
    }

    /* Exit the program */
    printf("mov rdi, 0\n"
           "call %s%s\n",
           FN_EXIT, CALL_SUBFIX);

    free(label_stack);
    free(input);
    return 0;
}
