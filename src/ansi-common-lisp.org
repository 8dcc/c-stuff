#+title: ANSI Common Lisp
#+property: header-args:lisp :tangle ansi-common-lisp.lisp :comments link
#+auto_tangle: t
#+author: 8dcc

* Chapter 2
** Chapter 2.10: Variables
The /let/ macro is used to create local variables. It takes 2 arguments, the first
one is a *list* of variable declarations and the second one is the body of
expressions. The body is where we want to use our new local variables.

Note: The first let is just used to show the multiple variable declarations. The
return value of a function is always the last expression, in this case the
second let.

#+begin_src lisp
(defun test-let ()
  (let ((var1 5)
        (var2 13)
        (var3 10))
    (+ var1 var2 var3))
  (let ((var1 7))       ; Note the list of declarations even with only 1
    (- var1 5)))

(test-let)
#+end_src

#+RESULTS:
: 2

** Chapter 2.13: Iteration
The /do/ macro is used for iteration and takes 3 arguments (the third one being
the contents of the loop). The first argument is, like with /let/, a *list* of
variable specifications. Each specification of this list has the following
format:

    ~(variable initial update)~

Which would be like:

    ~for (variable = initial; ...; update)~

The 2nd argument of the /do/ macro is a list containing the conditions of the loop
and extra expressions. This is the format:

    ~(stop-condition expression ...)~

The loop will keep going *until* the first expression is true. Once the expression
is true, it will stop the loop and start evaluating the rest of the expressions.
The /do/ macro will return the value of the last expression of the list.

After this list, the remaining arguments are expressions to be executed in the
while loop.

#+begin_src lisp :results output
(defun test-do (n)
  (do ((i 0 (+ i 1))
       (j 0 (+ j 3)))
      ((> i n)              ; Stop condition
       (format t "Finished first loop.~%")      ; Will get executed once it stops
       'done)               ; Last expresion, returned by do macro
    (format t "i: ~A j: ~A~%" i j))
  (do ((i n (- i 2)))       ; Note the list of declarations even with only 1
      ((<= i 0) 'done)
    (format t "i: ~A~%" i)))

(test-do 5)
#+end_src

#+RESULTS:
#+begin_example
i: 0 j: 0
i: 1 j: 3
i: 2 j: 6
i: 3 j: 9
i: 4 j: 12
i: 5 j: 15
Finished first loop.
i: 5
i: 3
i: 1
#+end_example

** Chapter 2.14: Functions as Objects
We used the /defun/ macro for declaring functions with a name (associating the
function to a symbol) but we don't need to do that. We can create a /lambda
expression/, which is how we create function objects (that we can later use as
parameters to functions, etc.).

To create this /lambda expression/ we use the /lambda/ symbol, a list of parameters,
and zero or more expressions (body).

#+begin_src lisp
(lambda (x y)       ; No name
  (* x y))
#+end_src

#+RESULTS:
: #<FUNCTION (LAMBDA (X Y)) {5368A96B}>

When we define a function with /defun/, we are just associating this /function
object/ to a symbol (the name of the function). When we use that symbol, we will
be referring to the function object.

What this means is that in reality we can use a lambda function just like we
would use a function name, so we can declare it and use it to call in the same
expression:

#+begin_src lisp
((lambda (x) (* x x)) 5)    ; 5 is a parameter
#+end_src

#+RESULTS:
: 25

We can assign the value of a lambda expression (function object) to a symbol
using /let/.

Here is an example using /let/:

#+begin_src lisp :results output
(let ((mylambda #'(lambda (x y)
                  (format t "I am an expression inside the lambda!~%")
                  (* x y))))
  (format t "Begining of the let expression block!~%")
  (format t "Lambda return: ~A~%" (funcall mylambda 5 3)))
#+end_src

#+RESULTS:
: Begining of the let expression block!
: I am an expression inside the lambda!
: Lambda return: 15

Keep in mind that we cannot call the function directly using:

    ~(mylambda 5 3)~

Because /mylambda/ is a variable that contains function object. Instead we need to
use /funcall/ or /apply/. Apply requires a list as its last argument. Usage:

    ~(funcall mylambda 5 3)~
    ~(apply mylambda '(5 3))~

Lambdas and let:

#+begin_src lisp :results output
;;  'symbol -> (quote symbol)
;; #'symbol -> (function symbol)
(funcall #'(lambda (x)
             (format t "(funcall) Value of x: ~A~%" x)) ; Body of lambda
         "Test 1")                                      ; Argument

(apply #'(lambda (x)
           (format t "  (apply) Value of x: ~A~%" x))   ; Body of lambda
       '("Test 2"))                                     ; Argument. Needs list
#+end_src

#+RESULTS:
: (funcall) Value of x: Test 1
:   (apply) Value of x: Test 2

** Exercises
1. Describe what happens when the following expressions are evaluated:
   a) First expression.

      #+begin_src lisp
      (+ (- 5 1) (+ 3 7))
      #+end_src

      #+RESULTS:
      : 14

      The =+= symbol is a function being called with 2 parameters, it starts
      evaluating the first one and encounters a =-= function call. It starts
      evaluating its first argument and because =5= evaluates to itself, it goes
      to the second argument, =1=, which also evaluates to itself. The 2 arguments
      are subtracted and the function returns =4=. The second parameter of the
      outer function is evaluated, and it encounters a =+= symbol, evaluates its
      arguments from left to right and returns =10=. The 2 arguments are finally
      passed to the outer =+= function and it returns =14=.

   b) Second expression.

      #+begin_src lisp
      (list 1 (+ 2 3))
      #+end_src

      #+RESULTS:
      | 1 | 5 |

      The =list= function gets called with 2 parameters. The first one evaluates
      to itself, so =1=. The second one is evaluated and the function call to =+=
      returns 5. The function returns a list from its arguments, in this case
      =(1, 5)=.

   c) Third expression.

      #+begin_src lisp
      (if (listp 1)
          (+ 1 2)
          (+ 3 4))
      #+end_src

      #+RESULTS:
      : 7

      The =if= function returns its second argument if the return value of the
      first one is not =nil=, or the third argument otherwise. In this case it
      begins evaluating the first argument (condition). The =listp= function
      checks if the parameter is a list, and in this case it gets called with =1=
      as its argument, so returns =nil=. Because the first argument of the =if= was
      =nil=, it jumps to its *third* argument. The ~(+ 3 4)~ expression returns =7=, and
      the =if= function returns that as well.

   d) Fourth expression.

      #+begin_src lisp
      (list (and (listp 3) t) (+ 1 2))
      #+end_src

      #+RESULTS:
      | NIL | 3 |

      The first expression that gets evaluated is the first argument of =list=.
      The =and= function returns =t= if all of its arguments are true, so it begins
      checking from left to right. The =listp= function is called and returns =nil=,
      since =3= is not a list. The =and= function stops evaluating arguments once
      one is =nil= (since the return value is obviously known then), so it returns
      =nil=. Once the =and= function returns, it starts evaluating the second
      argument of the outer call to =list=, in this case ~(+ 1 2)~, which returns =3=.
      The =list= function returns a list of those 2 arguments, in this case =(nil, 3)=

2. Give three distinct =cons= expressions that return =(a b c)=.

   Note that =cons= takes only 2 arguments, and adds the first one to the start of
   the second argument.

   #+begin_src lisp
   (cons 'a (cons 'b (cons 'c nil)))
   #+end_src

   #+RESULTS:
   | A | B | C |

   #+begin_src lisp
   (cons 'a '(b c))
   #+end_src

   #+RESULTS:
   | A | B | C |

   #+begin_src lisp
   (cons 'a (cons 'b '(c)))
   #+end_src

   #+RESULTS:
   | A | B | C |

3. Using =car= and =cdr=, define a function to return the fourth element of a list.

   #+begin_src lisp
   (defun fourth-elem (lst)
     (car (cdr (cdr (cdr lst)))))

   (fourth-elem '(10 20 30 40 50))
   #+end_src

   #+RESULTS:
   : 40

4. Define a function that takes two arguments and returns the greater of the
   two.

   #+begin_src lisp
   (defun greater (x y)
     (if (> x y)
         x
         y))

   (greater 5 12)
   #+end_src

   #+RESULTS:
   : 12

5. What do these functions do?
   a) Function one.

      #+begin_src lisp
      (defun enigma (x)
        (and (not (null x))
             (or (null (car x))
                 (enigma (cdr x)))))

      (enigma '(1 2 3))
      (enigma '(1 2 nil 4))
          #+end_src

      The =enigma= function returns the =and= of the following:
      - Is the argument a list with items?
      - The or of the following:
        - Is the first element of the argument =nil=?
        - The return value of this function is true with the rest of the
          list?

      So it returns true if the list has elements and if the first element is
      =nul=, or if that condition applies to the rest of the list. So basically
      this function could be called =has-nil=.

      In the 2nd call example, the process would be the following:
      1. Make sure the list ='(1 2 nil 4)= has elements.
      2. It does, check if the first element is =nil=.
      3. It isn't, call the function with ='(2 nil 4)=:
