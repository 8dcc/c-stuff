#+TITLE: Floating point modulus in Scheme
#+AUTHOR: 8dcc
#+OPTIONS: toc:2
#+STARTUP: nofold
#+PROPERTY: header-args:scheme :tangle fmod.scm
#+PROPERTY: header-args:C      :tangle fmod.c

* Introduction

When writing [[file:../color-palettes/README.org][my color palettes code]], I noticed that Scheme doesn't support a
floating point modulus operation, it only supports integers. I wanted to make a
function that worked similar to =mod= in [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Arithmetic-Operations.html#index-mod][Emacs Lisp]].

* The recursive Scheme version

I started with this simple function that supports only positive values.

#+begin_src scheme
;; Calculate remainder of X by Y. Supports floating point, but only positive
;; values.
(define (fmod x y)
  (if (< x y)
      x
      (fmod (- x y) y)))
#+end_src

Then, after a very non-mathematical approach, I came up with this version, that
supports both positive and negative values. See also [[file:../../../LaTeX/math/math.pdf][my math notes]].

#+begin_src scheme
;; Calculate remainder of X by Y, supporting floating point and negative values.
(define (fmod x y)
  (define (fmod-positive x y)
    (if (< x y)
        x
        (fmod-positive (- x y) y)))

  ;; If X is negative: X mod Y = Y - (|X| mod Y)
  (define (fmod-y-positive x y)
    (if (< x 0)
        (- y (fmod-positive (- x) y))
        (fmod-positive x y)))

  ;; If X is negative: X mod Y = -(-X mod -Y)
  (if (< y 0)
      (- (fmod-y-positive (- x) (- y)))
      (fmod-y-positive x y)))
#+end_src

However, after reading the Emacs source code, I came up with this
not-so-different version.

To understand =c-fmod=, see [[*The iterative C version][the iterative C version]].

#+begin_src scheme
;; Calculate remainder of X by Y, supporting floating point and negative values.
(define (fmod x y)
  ;; Equivalent function to fmod() from C's math.h
  (define (c-fmod x y)
    (let ((abs-x (abs x))
          (abs-y (abs y)))
      (if (< abs-x abs-y)
          x
          (let ((abs-result (c-fmod (- abs-x abs-y) abs-y)))
            (if (< x 0)
                (- abs-result)
                abs-result)))))

  (let ((result (c-fmod x y)))
    (if (or (and (< y 0) (> result 0))
            (and (>= y 0) (< result 0)))
        (+ result y)
        result)))
#+end_src

Some examples using my Scheme function:

#+begin_src scheme :results verbatim
(list
 (fmod 9 4)
 (fmod -9 4)
 (fmod 9 -4)
 (fmod -9 -4)
 (fmod 9.5 2.5)
 (fmod -9.5 2.5)
 (fmod 9.5 -2.5)
 (fmod -9.5 -2.5))
#+end_src

#+RESULTS:
: (1 3 -3 -1 2.0 0.5 -0.5 -2.0)

Those same examples using =mod= in Emacs Lisp:

#+begin_src emacs-lisp :results verbatim
(list
 (mod 9 4)
 (mod -9 4)
 (mod 9 -4)
 (mod -9 -4)
 (mod 9.5 2.5)
 (mod -9.5 2.5)
 (mod 9.5 -2.5)
 (mod -9.5 -2.5))
#+end_src

#+RESULTS:
: (1 3 -3 -1 2.0 0.5 -0.5 -2.0)

* The iterative C version

This initial version behaves like =fmod= from =math.h=, but it's slightly different
from Emacs' =mod=.

#+begin_src C :main no
#include <math.h>

double my_fmod(double a, double b) {
    int bNegativeResult = a < 0;

    a = fabs(a);
    b = fabs(b);

    while (a >= b)
        a -= b;

    return bNegativeResult ? -a : a;
}
#+end_src

This next function does behave like Emacs' =mod= by adding a simple conditional to
the previous function. Credits for this very smart method: [[https://github.com/emacs-mirror/emacs/blob/2119cd52cdb58221a850360bf65c91cf3bf4b47e/src/floatfns.c#L569-L582][emacs source code]].

#+begin_src C :main no
double my_emacs_fmod(double a, double b) {
    a = my_fmod(a, b);

    /* If the "remainder" comes out with the wrong sign, fix it. */
    if (b < 0 ? a > 0 : a < 0)
        a += b;

    return a;
}
#+end_src

We can test our functions against =fmod= from =math.h=. Remember to link with =-lm=.

#+begin_src C
#include <stdio.h>

int main(void) {
    printf("my_fmod(9 4)       -> %.2f\n", my_fmod(9, 4));
    printf("my_fmod(-9 4)      -> %.2f\n", my_fmod(-9, 4));
    printf("my_fmod(9 -4)      -> %.2f\n", my_fmod(9, -4));
    printf("my_fmod(-9 -4)     -> %.2f\n", my_fmod(-9, -4));
    printf("my_fmod(9.5 2.5)   -> %.2f\n", my_fmod(9.5, 2.5));
    printf("my_fmod(-9.5 2.5)  -> %.2f\n", my_fmod(-9.5, 2.5));
    printf("my_fmod(9.5 -2.5)  -> %.2f\n", my_fmod(9.5, -2.5));
    printf("my_fmod(-9.5 -2.5) -> %.2f\n", my_fmod(-9.5, -2.5));

    printf("fmod(9 4)       -> %.2f\n", fmod(9, 4));
    printf("fmod(-9 4)      -> %.2f\n", fmod(-9, 4));
    printf("fmod(9 -4)      -> %.2f\n", fmod(9, -4));
    printf("fmod(-9 -4)     -> %.2f\n", fmod(-9, -4));
    printf("fmod(9.5 2.5)   -> %.2f\n", fmod(9.5, 2.5));
    printf("fmod(-9.5 2.5)  -> %.2f\n", fmod(-9.5, 2.5));
    printf("fmod(9.5 -2.5)  -> %.2f\n", fmod(9.5, -2.5));
    printf("fmod(-9.5 -2.5) -> %.2f\n", fmod(-9.5, -2.5));

    printf("my_emacs_fmod(9 4)       -> %.2f\n", my_emacs_fmod(9, 4));
    printf("my_emacs_fmod(-9 4)      -> %.2f\n", my_emacs_fmod(-9, 4));
    printf("my_emacs_fmod(9 -4)      -> %.2f\n", my_emacs_fmod(9, -4));
    printf("my_emacs_fmod(-9 -4)     -> %.2f\n", my_emacs_fmod(-9, -4));
    printf("my_emacs_fmod(9.5 2.5)   -> %.2f\n", my_emacs_fmod(9.5, 2.5));
    printf("my_emacs_fmod(-9.5 2.5)  -> %.2f\n", my_emacs_fmod(-9.5, 2.5));
    printf("my_emacs_fmod(9.5 -2.5)  -> %.2f\n", my_emacs_fmod(9.5, -2.5));
    printf("my_emacs_fmod(-9.5 -2.5) -> %.2f\n", my_emacs_fmod(-9.5, -2.5));

    return 0;
}
#+end_src
